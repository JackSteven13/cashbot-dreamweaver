
import { useCallback } from 'react';
import { calculateTimeUntilMidnight } from '@/utils/timeUtils';

interface UseStatsCycleManagementParams {
  setAdsCount: React.Dispatch<React.SetStateAction<number>>;
  setRevenueCount: React.Dispatch<React.SetStateAction<number>>;
  setDisplayedAdsCount: React.Dispatch<React.SetStateAction<number>>;
  setDisplayedRevenueCount: React.Dispatch<React.SetStateAction<number>>;
  dailyAdsTarget: number;
  dailyRevenueTarget: number;
}

export const useStatsCycleManagement = ({
  setAdsCount,
  setRevenueCount,
  setDisplayedAdsCount,
  setDisplayedRevenueCount,
  dailyAdsTarget,
  dailyRevenueTarget
}: UseStatsCycleManagementParams) => {
  // Schedule cycle update at midnight, Paris time
  const scheduleCycleUpdate = useCallback(() => {
    const timeUntilMidnight = calculateTimeUntilMidnight();
    
    // Convert to hours for logs
    const hoursUntilMidnight = Math.floor(timeUntilMidnight / 1000 / 60 / 60);
    const minutesUntilMidnight = Math.floor((timeUntilMidnight / 1000 / 60) % 60);
    
    console.log(`Next counter reset in ${hoursUntilMidnight} hours and ${minutesUntilMidnight} minutes`);
    
    const resetTimeout = setTimeout(() => {
      // Reset counters at midnight, Paris time
      setAdsCount(0);
      setRevenueCount(0);
      setDisplayedAdsCount(0);
      setDisplayedRevenueCount(0);
      
      // Schedule next reset
      scheduleCycleUpdate();
    }, timeUntilMidnight);
    
    return resetTimeout;
  }, [setAdsCount, setRevenueCount, setDisplayedAdsCount, setDisplayedRevenueCount]);
  
  // Improved simulation with fewer agents and much smaller increments
  // for a significantly slower counter progression
  const incrementCountersRandomly = useCallback(() => {
    // Reduce number of active agents to slow down progression dramatically
    const activeAgents = 1 + Math.floor(Math.random() * 2); // Between 1-2 agents (was 3-4)
    
    // Each agent processes a variable number of ads
    setAdsCount(prevAdsCount => {
      // Don't exceed daily target
      if (prevAdsCount >= dailyAdsTarget) return dailyAdsTarget;
      
      let totalAdsIncrement = 0;
      
      // Simulate each agent processing ads, with drastically reduced efficiency
      for (let i = 0; i < activeAgents; i++) {
        // Variable ad duration (20-60 seconds)
        // Agents with varying efficiency
        const agentEfficiency = 0.7 + Math.random() * 0.6; // 70% to 130% efficiency
        // Significantly reduce ads per agent
        const adsPerAgent = Math.floor((dailyAdsTarget * 0.00005) * agentEfficiency); // Further reduced from 0.0001
        totalAdsIncrement += adsPerAgent;
      }
      
      // Limit to avoid exceeding target
      const newAdsCount = Math.min(prevAdsCount + totalAdsIncrement, dailyAdsTarget);
      
      // Variable revenue generated by ads (between 0.45€ and 3.30€ per ad)
      setRevenueCount(prevRevenueCount => {
        if (prevRevenueCount >= dailyRevenueTarget) return dailyRevenueTarget;
        
        let totalRevenueIncrement = 0;
        
        for (let i = 0; i < totalAdsIncrement; i++) {
          // Simulate different ad values
          // Most are low value, a few are high value
          let adValue;
          const adTypeRandom = Math.random();
          
          if (adTypeRandom > 0.97) {
            // Premium ads (3%)
            adValue = 2.20 + Math.random() * 1.10; // 2.20€ - 3.30€
          } else if (adTypeRandom > 0.85) {
            // Medium-high ads (12%)
            adValue = 1.10 + Math.random() * 1.10; // 1.10€ - 2.20€
          } else if (adTypeRandom > 0.60) {
            // Medium ads (25%)
            adValue = 0.70 + Math.random() * 0.40; // 0.70€ - 1.10€
          } else {
            // Standard ads (60%)
            adValue = 0.45 + Math.random() * 0.25; // 0.45€ - 0.70€
          }
          
          totalRevenueIncrement += adValue;
        }
        
        // Adjust total revenue to be consistent with daily target
        const adjustmentFactor = dailyRevenueTarget / dailyAdsTarget;
        totalRevenueIncrement = totalRevenueIncrement * adjustmentFactor * 0.8;
        
        return Math.min(prevRevenueCount + totalRevenueIncrement, dailyRevenueTarget);
      });
      
      return newAdsCount;
    });
  }, [dailyAdsTarget, dailyRevenueTarget, setAdsCount, setRevenueCount]);

  return {
    scheduleCycleUpdate,
    incrementCountersRandomly
  };
};
